package compilador;

// Importación de clases
import java_cup.runtime.*;
import java.io.FileReader;
import producciones.*;
   
/* 
  Esta sección del código se agrega a la clase resultante
*/
parser code {:
    
    /*Entrada: Es un mensaje de error de tipo String y el símbolo de tipo Object 
      Salida: No tiene
      Error encontrado.
      Se hace un Override al método report_error de la clase lr_parser de CUP 
    */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }
   
    /*Entrada: Es un mensaje de error de tipo String y el símbolo de tipo Object 
      Salida: No tiene 
      Error de donde el sistema no se puede recuper
       Se hace un Override al método report_fatal_error de la clase lr_parser de CUP
    */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
    }

    /* Se ejecuta el método main para ejecutar el analizador léxico y el analizador
       sintáctico. Se envía como parámetro la tabla de símbolos.
    */
    public static void main(String[] args){
        try {
            AnalizadorSintactico asin = new AnalizadorSintactico(
                    new AnalizadorLexico( new FileReader(args[0])));
            Object result = asin.parse().value;
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
:};
   

   
// ------------Declaracion de terminales y no terminales
   
/* TERMINALES
   Se listan todos los tokens que se vayan a utilizar para la elaboración de
   producciones, estos son obtenidos por el analizador lexico. 
*/
terminal           IDENTIFIER,
                   MINUS, PLUS, DIVIDE, MULTI, MODULE, POWER, PLUS_PLUS, MINUS_MINUS,
                   GREATER, GREATER_EQUAL, MINOR, MINOR_EQUAL, EQUAL_EQUAL, DIFFERENT, AND, OR,
                   OPEN_PAREN, CLOSE_PAREN, TRUE, FALSE, NULL, OPEN_BRACKET, CLOSE_BRACKET, COMMA,
                   INT, FLOAT, BOOL, CHAR, STRING, EQUAL, FINAL, FOR, RETURN, READ, PRINT, NOT,
                   OPEN_KEY, CLOSE_KEY, IF, ELSE, ELIF, BREAK, COMMENT,
                   MAIN;
terminal Integer   INTEGER;
terminal Double    DECIMAL;
terminal String    CHARCHAIN;
terminal Character CHARACTER;

/*NO TERMINALES 
  Se listas todos los no terminales que se elaboran en las producciones. Se utiliza Object
  para indicar que estos no tienen un tipo definido, pudiendo ser un entero o String.
*/

non terminal Object operation, relational_operator, additive_operation, additive_operator,
                    multiplicative_operation, multiplicative_operator, unary_operation,
                    unary_operator, basic_operation, empty, create_var, type, 
                    sentences, call_function, createArray, arrayList, modifyArrayElement, 
                    block, create_function, parameters, parameter_list, for_structure, if_structure, else_structure, 
                    elif_structure, main_function, assing_var, negation,
                    init_program;

   
/* -------------Precedencia y producciones
   
/*PRECEDENCIA

  En este caso se utiliza la precedencia para eliminar la ambiguedad que se genera en la producción type,
  al tener un INT que hace referencia al tipo entero y un INT[] que hace referencia al tipo arreglo, de igual manera para la ambiguedad que se presenta con 
  con el ELIF y el ELSE.
*/
  precedence right INT;
    precedence right CHAR;
  precedence right ELIF; 
  precedence right ELSE; 
  

/* PRODUCCIONES   
 
/* 
  El programa inicia con la producción init_program, esta indica que se pueden crear funciones y luego
  utilizar la función main, o solo hacer uso de esta última. A partir de esta se desencadena el uso
  de las demás producciones.
*/

    start with init_program;

    init_program ::= create_function:cf main_function:mf
                    {:
                      InitProgram ip = new InitProgram(mf, cf);
                      RESULT = ip;
                    :}
                   | main_function:mf
                    {:
                      FunctionList cf = new FunctionList();
                      InitProgram ip = new InitProgram(mf, cf);
                      RESULT = ip;
                    :}
                   ;

    main_function ::= INT MAIN OPEN_PAREN CLOSE_PAREN block:b
                      {:
                        Main m = new Main(b, null);
                        RESULT = m;
                      :}
                    ;

    create_function ::= create_function:cf type:t IDENTIFIER:id OPEN_PAREN parameters:p CLOSE_PAREN block:b
                        {:
                          Function f = new Function(t, id, p, b, null);
                          if(cf == null) cf = new FunctionList();
                          cf.addFunction(f);
                          RESULT = cf;
                        :}
                      | type IDENTIFIER OPEN_PAREN parameters CLOSE_PAREN block
                        {:
                          Function f = new Function(t, id, p, b, null);
                          FunctionList cf = new FunctionList();
                          cf.addFunction(f);
                          RESULT = cf;
                        :}
                      ;

    parameters ::= empty
                  {:
                    RESULT = new ParametersFunction();

                  :}
                 | parameters:pa COMMA type:t IDENTIFIER:id
                  {:
                    Parameters p = new Parameters(t, id);
                    if(pa == null) pa = new ParametersFunction();
                    pa.addParameter(p);
                    RESULT = pa;

                  :}
                 | type:t IDENTIFIER:id
                  {:
                    Parameters p = new Parameters(t, id);
                    ParametersFunction pa = new ParametersFunction();
                    pa.addParameter(p);
                    RESULT = pa;

                  :}
                 ;

    block ::=  OPEN_KEY sentences CLOSE_KEY
            |  error CLOSE_KEY
            ; 

    sentences ::= empty
                 {:
                    RESULT = new Sentences();
                 :}
               | operation:op FINAL sentences:sent
                 {:
                    if(sent == null) sent = new Sentences();
                    OperationSentence opr = new(op);
                    sent.addSentence(opr);
                    RESULT = sent;
                 :}
               | create_var:op FINAL sentences:sent
                 {:
                    if(sent == null) sent = new Sentences();
                    sent.addSentence(op);
                    RESULT = sent;
                 :}
               | assing_var:op FINAL sentences:sent
                 {:
                    if(sent == null) sent = new Sentences();
                    sent.addSentence(op);
                    RESULT = sent;
                 :}
               | modifyArrayElement:op FINAL sentences:sent
                 {:
                    if(sent == null) sent = new Sentences();
                    sent.addSentence(op);
                    RESULT = sent;
                 :}
               | createArray:op FINAL sentences:sent
                 {:
                    if(sent == null) sent = new Sentences();
                    sent.addSentence(op);
                    RESULT = sent;
                 :}
               | if_structure:op sentences:sent
                 {:
                    if(sent == null) sent = new Sentences();
                    sent.addSentence(op);
                    RESULT = sent;
                 :}
               | FOR:fr OPEN_PAREN for_structure:fs CLOSE_PAREN block:bl sentences:sent
                 {:
                    if(sent == null) sent = new Sentences();
                    For ff = new For(fs, bl, new int[] {fr.getRow(), fr.getColumn()});
                    sent.addSentence(ff);
                    RESULT = sent;
                 :}
               | RETURN:rt operation:op FINAL sentences:sent
                 {:
                    if(sent == null) sent = new Sentences();
                    Return ff = new Return(op, new int[] {rt.getRow(), rt.getColumn()});
                    sent.addSentence(ff);
                    RESULT = sent;
                 :}
               | BREAK:br FINAL sentences:sent
                 {:
                    if(sent == null) sent = new Sentences();
                    Break ff = new Break(new int[] {br.getRow(), br.getColumn()});
                    sent.addSentence(ff);
                    RESULT = sent;
                 :}
               | PRINT:pr OPEN_PAREN operation:op CLOSE_PAREN FINAL sentences:sent
                 {:
                    if(sent == null) sent = new Sentences();
                    Print ff = new Print(op, new int[] {pr.getRow(), pr.getColumn()});
                    sent.addSentence(ff);
                    RESULT = sent;
                 :}
               | READ:pr OPEN_PAREN IDENTIFIER:id CLOSE_PAREN FINAL sentences:sent
                 {:
                    if(sent == null) sent = new Sentences();
                    Read ff = new Read((String)id.getValue(), new int[] {pr.getRow(), pr.getColumn()});
                    sent.addSentence(ff);
                    RESULT = sent;
                 :}
               | error
                 {:
                    RESULT = new Sentences();
                 :}
               | COMMENT sentences:sent
                 {:
                    if(sent == null) sent = new Sentences();
                    RESULT = sent;
                 :}
               ;

    for_structure ::= create_var:cv FINAL operation:op1 FINAL operation:op2
                    {:
                      RESULT = new  ForStructure(cv, op1, op2); 
                    :}
                     ;

    if_structure ::= IF negation OPEN_PAREN operation:op CLOSE_PAREN OPEN_KEY sentences:s1 CLOSE_KEY
                       	elif_structure:elf
		        else_structure:els
                        {:
                            RESULT = new If(op, s1, elf, els);
                        :}
                        ;

    else_structure ::= empty
                        {:
                           RESULT = null;
                        :}
		       |ELSE OPEN_KEY sentences:sent CLOSE_KEY
                        {:
                           RESULT = sent;
                        :}
		       ;

    elif_structure ::= empty
                        {:
                          RESULT = new Vector<Elif>(); 
                        :}
                       | ELIF:elf negation OPEN_PAREN operation:op1 CLOSE_PAREN OPEN_KEY sentences:s1 CLOSE_KEY
                        {:
                            Vector<Elif> al = new Vector<Elif>();
                            Elif elf = new Elif(op1, s1, new int[] {elf.getRow(), elf.getColumn()});
                            al.add(elf);
                            RESULT = al;
                        :}
		       | elif_structure:elfs ELIF negation OPEN_PAREN operation:op1 CLOSE_PAREN OPEN_KEY sentences:s1 CLOSE_KEY
                         {:
                            if(elfs == null) elfs = new Vector<Elif>();
                            Elif elf = new Elif(op1, s1, new int[] {elf.getRow(), elf.getColumn()});
                            elfs.add(elf);
                            RESULT = elfs;
                         :}
                        ;


    operation ::= operation:op relational_operator:ro additive_operation:ao
                  {:
                    if(ro === ">") RESULT = new Greater(op, ao, new int[] {ro.getRow(), ro.getColumn()});
                    if(ro === ">=") RESULT = new GreaterEqual(op, ao, new int[] {ro.getRow(), ro.getColumn()});
                    if(ro === "<") RESULT = new Minor(op, ao, new int[] {ro.getRow(), ro.getColumn()});
                    if(ro === "<=") RESULT = new MinorEqual(op, ao, new int[] {ro.getRow(), ro.getColumn()});
                    if(ro === "==") RESULT = new EqualEqual(op, ao, new int[] {ro.getRow(), ro.getColumn()});
                    if(ro === "!=") RESULT = new Different(op, ao, new int[] {ro.getRow(), ro.getColumn()});                    
                  :}
                | additive_operation:ao
                  {:
                    RESULT = ao;
                  :}
                ;

    relational_operator ::= GREATER:g
                            {:
                              RESULT = g;
                            :}
                          | GREATER_EQUAL:ge
                            {:
                              RESULT = ge;
                            :}
                          | MINOR:m
                            {:
                              RESULT = m;
                            :}
                          | MINOR_EQUAL:me
                            {:
                              RESULT = me;
                            :}
                          | EQUAL_EQUAL:ee
                            {:
                              RESULT = ee;
                            :}
                          | DIFFERENT:d
                            {:
                              RESULT = d;
                            :}
                          ;

    additive_operation ::= additive_operation:ao additive_operator:aop multiplicative_operation:mo
                          {:
                            if(aop === "-") RESULT = new Minus(ao, mo, new int[] {ro.getRow(), ro.getColumn()});
                            if(aop === "+") RESULT = new Plus(ao, mo, new int[] {ro.getRow(), ro.getColumn()});
                            if(aop === "|") RESULT = new Or(ao, mo, new int[] {ro.getRow(), ro.getColumn()});                
                          :}
                         | multiplicative_operation:mo
                          {:
                            RESULT = mo;
                          :}
                         ;

    additive_operator   ::= MINUS:m
                            {:
                              RESULT = m;
                            :}
                          | PLUS:p
                            {:
                              RESULT = p;
                            :}
                          | OR:o
                            {:
                              RESULT = o;
                            :}
                          ;    

    multiplicative_operation ::= multiplicative_operation:mo multiplicative_operator:mop unary_operation:uo
                                {:
                                  if(mop === "/") RESULT = new Divide(mo,uo, new int[] {ro.getRow(), ro.getColumn()});
                                  if(mop === "*") RESULT = new Multi(mo, uo, new int[] {ro.getRow(), ro.getColumn()});
                                  if(mop === "**") RESULT = new Power(mo, uo, new int[] {ro.getRow(), ro.getColumn()});
                                  if(mop === "~") RESULT = new Module(mo, uo, new int[] {ro.getRow(), ro.getColumn()});
                                  if(mop === "&") RESULT = new And(mo, uo, new int[] {ro.getRow(), ro.getColumn()});                   
                                :}
                               | unary_operation:uo
                                {:
                                  RESULT = uo;
                                :}
                               ;

    multiplicative_operator ::= DIVIDE:d
                                {:
                                  RESULT = d;
                                :}
                              | MULTI:m
                                {:
                                  RESULT = m;
                                :}
                              | POWER:p
                                {:
                                  RESULT = p;
                                :}
                              | MODULE:mo
                                {:
                                  RESULT = mo;
                                :}
                              | AND:a
                                {:
                                  RESULT = a;
                                :}
                              ; 

    unary_operation ::= unary_operator:uop unary_operation:uo
                        {:
                          if(uop === "--") RESULT = new MinusMinus(uo, new int[] {ro.getRow(), ro.getColumn()});
                          if(uop === "++") RESULT = new PlusPlus(uo, new int[] {ro.getRow(), ro.getColumn()});
                          if(uop === "-") RESULT = new MinusUnary(uo, new int[] {ro.getRow(), ro.getColumn()});                
                        :}
                      | basic_operation:ba
                        {:
                          RESULT = ba;
                        :}
                      ;

    unary_operator ::= MINUS_MINUS:mm
                      {:
                        RESULT = mm;
                      :}
                     | PLUS_PLUS:pp
                      {:
                        RESULT = pp;
                      :}
                     | MINUS:m
                      {:
                        RESULT = m;
                      :}
                     ;

    basic_operation ::= INTEGER:i
                        {:
                            RESULT = new IntLiteral((int)i.getValue(), new int[] {i.getRow(), i.getCol()});
                        :}
                      | DECIMAL:f
                        {:
                            RESULT = new FloatLiteral((float)f.getValue(), new int[] {f.getRow(), f.getCol()});
                        :}
                      | CHARCHAIN:s
                        {:
                            RESULT = new StringLiteral((String)s.getValue(), new int[] {s.getRow(), s.getCol()});
                        :}
                      | CHARACTER:c
                        {:
                            RESULT = new CharLiteral((char)c.getValue(), new int[] {c.getRow(), c.getCol()});
                        :}
                      | IDENTIFIER:id
                        {:
                            RESULT = new Identifier((String)id.getValue(), new int[] {id.getRow(), id.getCol()});
                        :}
                      | TRUE:b
                        {:
                            RESULT = new BoolLiteral(true, new int[] {b.getRow(), b.getCol()});
                        :}
                      | FALSE:b
                        {:
                            RESULT = new BoolLiteral(false, new int[] {b.getRow(), b.getCol()});
                        :}
                      | negation OPEN_PAREN operation:op CLOSE_PAREN
                        {:
                            RESULT = op;
                        :} 
                      | IDENTIFIER:id OPEN_BRACKET INTEGER:i CLOSE_BRACKET
                        {:
                            RESULT = new ArrayPositionOperation((String)id.getValue(), (int)i.getValue(),new int[] {id.getRow(), id.getCol()});
                        :} 
                      | OPEN_BRACKET  arrayList:al CLOSE_BRACKET 
                        {:
                            RESULT = new ArrayListAssigment(al);
                        :} 
                      | call_function:cf
                        {:
                            RESULT = cf;
                        :} 
                      | NULL:nl
                        {:
                            RESULT = new NullLiteral(null, new int[] {nl.getRow(), nl.getCol()});
                        :} 
                      ;

   parameter_list ::= parameter_list:pl COMMA operation:op
                {:
                    if(pl == null) pl = new ArrayList();
                    pl.AddOperation(op);
                    RESULT = pl;
                 :}
                     | operation:op
                {:
                    ArrayList pl = new ArrayList();
                    pl.AddOperation(op);
                    RESULT = pl;
                 :}
                     ;

    call_function ::= IDENTIFIER:id OPEN_PAREN parameter_list:pl CLOSE_PAREN
                {:
                    Identifier identifier = new Identifier((String)id.getValue(), new int[] {id.getRow(), id.getColumn()});
                    RESULT = new CallFunction(identifier.getName(), pl, new int[] {id.getRow(), id.getColumn()});
                :}
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN
                {:
                    Identifier identifier = new Identifier((String)id.getValue(), new int[] {id.getRow(), id.getColumn()});
                    RESULT = new CallFunction(identifier.getName(), null, new int[] {id.getRow(), id.getColumn()});
                :}
                    ;

    arrayList ::= empty
                 {:
                    RESULT = new ArrayList();
                 :}
                 | operation:op
                 {:
                    ArrayList al = new ArrayList();
                    al.AddOperation(op);
                    RESULT = al;
                 :}
                 | operation:op COMMA arrayList:al
                 {:
                    if(al == null) al = new ArrayList();
                    al.AddOperation(op);
                    RESULT = al;
                 :}
                 ;

    empty ::=
            ;

    modifyArrayElement ::= IDENTIFIER:id OPEN_BRACKET INTEGER:i CLOSE_BRACKET EQUAL operation:op
                {:
                    Identifier identifier = new Identifier((String)id.getValue(), new int[] {id.getRow(), id.getColumn()});
                    RESULT = new ModifyArray(identifier, i, op, new int[] {id.getRow(), id.getColumn()});
                :}
                ;

    createArray ::= type:t IDENTIFIER:id OPEN_BRACKET INTEGER:i CLOSE_BRACKET
                {:
                    Identifier identifier = new Identifier((String)id.getValue(), new int[] {id.getRow(), id.getColumn()});
                    RESULT = new CreateArray(t, identifier, (int)i.getValue(), null, new int[] {id.getRow(), id.getColumn()});
                :}
                | type:t IDENTIFIER:id OPEN_BRACKET CLOSE_BRACKET EQUAL OPEN_BRACKET arrayList:al CLOSE_BRACKET
                {:
                    Identifier identifier = new Identifier((String)id.getValue(), new int[] {id.getRow(), id.getColumn()});
                    RESULT = new CreateArray(t, identifier, 0, al, new int[] {id.getRow(), id.getColumn()});
                :}
                ;


    create_var ::= type:t IDENTIFIER:d EQUAL operation:op
                {:
                    Identifier identifier = new Identifier((String)id.getValue(), new int[] {id.getRow(), id.getColumn()});
                    RESULT = new CreateVar(t, identifier, op, new int[] {id.getRow(), id.getColumn()});
                :}
                 | type:t IDENTIFIER:id
                {:
                    Identifier identifier = new Identifier((String)id.getValue(), new int[] {id.getRow(), id.getColumn()});
                    RESULT = new CreateVar(t, identifier, null, new int[] {id.getRow(), id.getColumn()});
                :}
                 ;

    assing_var ::= IDENTIFIER:id EQUAL operation:op
                {:
                    Identifier identifier = new Identifier((String)id.getValue(), new int[] {id.getRow(), id.getColumn()});
                    RESULT = new AssignVar(identifier, op, new int[] {id.getRow(), id.getColumn()});
                :}
                ;


    negation ::= empty
		| NOT
		;


    type ::= INT
            {:
                RESULT = new IntType();
            :}
           | FLOAT
           {:
                RESULT = new FloatType();
            :}
           | CHAR
            {:
                RESULT = new CharType();
            :}
           | STRING
           {:
                RESULT = new StringType();
            :}
           | BOOL
           {:
                RESULT = new BooleanType();
            :}
           ;
