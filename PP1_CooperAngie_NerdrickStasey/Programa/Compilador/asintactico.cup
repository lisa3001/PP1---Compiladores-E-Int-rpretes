package compilador;

// Importación de clases
import java_cup.runtime.*;
import java.io.FileReader;
   
/* 
  Esta sección del código se agrega a la clase resultante
*/
parser code {:
    
    /*Entrada: Es un mensaje de error de tipo String y el símbolo de tipo Object 
      Salida: No tiene
      Error encontrado.
      Se hace un Override al método report_error de la clase lr_parser de CUP 
    */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }
   
    /*Entrada: Es un mensaje de error de tipo String y el símbolo de tipo Object 
      Salida: No tiene 
      Error de donde el sistema no se puede recuper
       Se hace un Override al método report_fatal_error de la clase lr_parser de CUP
    */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
    }

    /* Se ejecuta el método main para ejecutar el analizador léxico y el analizador
       sintáctico. Se envía como parámetro la tabla de símbolos.
    */
    public static void main(String[] args){
        try {
            AnalizadorSintactico asin = new AnalizadorSintactico(
                    new AnalizadorLexico( new FileReader(args[0])));
            Object result = asin.parse().value;
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
:};
   

   
// ------------Declaracion de terminales y no terminales
   
/* TERMINALES
   Se listan todos los tokens que se vayan a utilizar para la elaboración de
   producciones, estos son obtenidos por el analizador lexico. 
*/
terminal           IDENTIFIER,
                   MINUS, PLUS, DIVIDE, MULTI, MODULE, POWER, PLUS_PLUS, MINUS_MINUS,
                   GREATER, GREATER_EQUAL, MINOR, MINOR_EQUAL, EQUAL_EQUAL, DIFFERENT, AND, OR,
                   OPEN_PAREN, CLOSE_PAREN, TRUE, FALSE, NULL, OPEN_BRACKET, CLOSE_BRACKET, COMMA,
                   INT, FLOAT, BOOL, CHAR, STRING, EQUAL, FINAL, FOR, RETURN, READ, PRINT, NOT,
                   OPEN_KEY, CLOSE_KEY, IF, ELSE, ELIF, BREAK, COMMENT,
                   MAIN;
terminal Integer   INTEGER;
terminal Double    DECIMAL;
terminal String    CHARCHAIN;
terminal Character CHARACTER;

/*NO TERMINALES 
  Se listas todos los no terminales que se elaboran en las producciones. Se utiliza Object
  para indicar que estos no tienen un tipo definido, pudiendo ser un entero o String.
*/

non terminal Object operation, relational_operator, additive_operation, additive_operator,
                    multiplicative_operation, multiplicative_operator, unary_operation,
                    unary_operator, basic_operation, empty, create_var, type, 
                    sentences, sentence, call_function, createArray, arrayList, modifyArrayElement, 
                    block, create_function, parameters, parameter_list, for_structure, if_structure, else_structure, 
                    elif_structure, main_function, assing_var, negation,
                    init_program;

   
/* -------------Precedencia y producciones
   
/*PRECEDENCIA

  En este caso se utiliza la precedencia para eliminar la ambiguedad que se genera en la producción type,
  al tener un INT que hace referencia al tipo entero y un INT[] que hace referencia al tipo arreglo, de igual manera para la ambiguedad que se presenta con 
  con el ELIF y el ELSE.
*/
  precedence right INT;
    precedence right CHAR;
  precedence right ELIF; 
  precedence right ELSE; 
  

/* PRODUCCIONES   
 
/* 
  El programa inicia con la producción init_program, esta indica que se pueden crear funciones y luego
  utilizar la función main, o solo hacer uso de esta última. A partir de esta se desencadena el uso
  de las demás producciones.
*/

    start with init_program;

    init_program ::= create_function main_function
                   | main_function
                   ;

    main_function ::= INT MAIN OPEN_PAREN CLOSE_PAREN block
                    ;

    create_function ::= create_function type IDENTIFIER OPEN_PAREN parameters CLOSE_PAREN block
                      | type IDENTIFIER OPEN_PAREN parameters CLOSE_PAREN block
                      ;

    parameters ::= empty
                 | parameters COMMA type IDENTIFIER
                 | type IDENTIFIER
                 ;

    block ::=  OPEN_KEY sentences CLOSE_KEY
            |  error CLOSE_KEY
            ; 

    sentences ::= empty
                 {
                    RESULT = new Sentences();
                 }
               | operation:op FINAL sentences:sent
                 {
                    if(sent == null) sent = new Sentences();
                    sent.addSentence(op);
                    RESULT = sent;
                 }
               | create_var:op FINAL sentences:sent
                 {
                    if(sent == null) sent = new Sentences();
                    sent.addSentence(op);
                    RESULT = sent;
                 }
               | assing_var:op FINAL sentences:sent
                 {
                    if(sent == null) sent = new Sentences();
                    sent.addSentence(op);
                    RESULT = sent;
                 }
               | modifyArrayElement:op FINAL sentences:sent
                 {
                    if(sent == null) sent = new Sentences();
                    sent.addSentence(op);
                    RESULT = sent;
                 }
               | createArray:op FINAL sentences:sent
                 {
                    if(sent == null) sent = new Sentences();
                    sent.addSentence(op);
                    RESULT = sent;
                 }
               | if_structure:op sentences:sent
                 {
                    if(sent == null) sent = new Sentences();
                    sent.addSentence(op);
                    RESULT = sent;
                 }
               | FOR:fr OPEN_PAREN for_structure:fs CLOSE_PAREN block:bl sentences:sent
                 {
                    if(sent == null) sent = new Sentences();
                    For ff = new For(fs, bl, new int[] {fr.getRow(), fr.getColumn()});
                    sent.addSentence(ff);
                    RESULT = sent;
                 }
               | RETURN:rt operation:op FINAL sentences:sent
                 {
                    if(sent == null) sent = new Sentences();
                    Return ff = new Return(op, new int[] {rt.getRow(), rt.getColumn()});
                    sent.addSentence(ff);
                    RESULT = sent;
                 }
               | BREAK:br FINAL sentences:sent
                 {
                    if(sent == null) sent = new Sentences();
                    Break ff = new Break(new int[] {br.getRow(), br.getColumn()});
                    sent.addSentence(ff);
                    RESULT = sent;
                 }
               | PRINT:pr OPEN_PAREN operation:op CLOSE_PAREN FINAL sentences:sent
                 {
                    if(sent == null) sent = new Sentences();
                    Print ff = new Print(op, new int[] {pr.getRow(), pr.getColumn()});
                    sent.addSentence(ff);
                    RESULT = sent;
                 }
               | READ:pr OPEN_PAREN IDENTIFIER:id CLOSE_PAREN FINAL sentences:sent
                 {
                    if(sent == null) sent = new Sentences();
                    Read ff = new Read(id, new int[] {pr.getRow(), pr.getColumn()});
                    sent.addSentence(ff);
                    RESULT = sent;
                 }
               | error
                 {
                    RESULT = new Sentences();
                 }
               | COMMENT sentences:sent
                 {
                    if(sent == null) sent = new Sentences();
                    RESULT = sent;
                 }
               ;

    for_structure ::= create_var:cv FINAL operation:op1 FINAL operation:op2
                    {
                      RESULT = new  ForStructure(cv, op1, op2); 
                    }
                     ;

    if_structure ::= IF negation OPEN_PAREN operation:op CLOSE_PAREN OPEN_KEY sentences:s1 CLOSE_KEY
                       	elif_structure:elf
		        else_structure:els
                        {
                            RESULT = new If(op, s1, elf, els);
                        }
                        ;

    else_structure ::= empty
                        {
                           RESULT = null;
                        }
		       |ELSE OPEN_KEY sentences:sent CLOSE_KEY
                        {
                           RESULT = sent;
                        }
		       ;

    elif_structure ::= empty
                        {
                          RESULT = new Vector<Elif>(); 
                        }
                       | ELIF:elf negation OPEN_PAREN operation:op1 CLOSE_PAREN OPEN_KEY sentences:s1 CLOSE_KEY
                        {
                            Vector<Elif> al = new Vector<Elif>();
                            Elif elf = new Elif(op1, s1, new int[] {elf.getRow(), elf.getColumn()});
                            al.add(elf);
                            RESULT = al;
                        }
		       | elif_structure:elfs ELIF negation OPEN_PAREN operation:op1 CLOSE_PAREN OPEN_KEY sentences:s1 CLOSE_KEY
                         {
                            if(elfs == null) elfs = new Vector<Elif>();
                            Elif elf = new Elif(op1, s1, new int[] {elf.getRow(), elf.getColumn()});
                            elfs.add(elf);
                            RESULT = elfs;
                         }
                        ;


    operation ::= operation relational_operator additive_operation
                | additive_operation
                ;

    relational_operator ::= GREATER
                          | GREATER_EQUAL
                          | MINOR
                          | MINOR_EQUAL
                          | EQUAL_EQUAL
                          | DIFFERENT
                          ;

    additive_operation ::= additive_operation additive_operator multiplicative_operation
                         | multiplicative_operation
                         ;

    additive_operator   ::= MINUS
                          | PLUS
                          | OR
                          ;    

    multiplicative_operation ::= multiplicative_operation multiplicative_operator unary_operation
                               | unary_operation 
                               ;

    multiplicative_operator ::= DIVIDE
                              | MULTI
                              | POWER
                              | MODULE
                              | AND
                              ; 

    unary_operation ::= unary_operator unary_operation
                      | basic_operation
                      ;

    unary_operator ::= MINUS_MINUS
                     | PLUS_PLUS
                     | MINUS
                     ;

    basic_operation ::= INTEGER
                      | DECIMAL
                      | CHARCHAIN
                      | CHARACTER
                      | IDENTIFIER
                      | TRUE
                      | FALSE
                      | negation OPEN_PAREN operation CLOSE_PAREN 
                      | IDENTIFIER OPEN_BRACKET INTEGER CLOSE_BRACKET
                      | OPEN_BRACKET  arrayList CLOSE_BRACKET 
                      | call_function
                      | NULL
                      ;

   parameter_list ::= parameter_list:pl COMMA operation:op
                {
                    if(pl == null) pl = new ArrayList();
                    pl.AddOperation(op);
                    RESULT = pl;
                 }
                     | operation:op
                {
                    ArrayList pl = new ArrayList();
                    pl.AddOperation(op);
                    RESULT = pl;
                 }
                     ;

    call_function ::= IDENTIFIER:id OPEN_PAREN parameter_list:pl CLOSE_PAREN
                {
                    Identifier identifier = new Identifier((String)id.getValue(), new int[] {id.getRow(), id.getColumn()});
                    RESULT = new CallFunction(identifier.getName(), pl, new int[] {id.getRow(), id.getColumn()});
                }
                    | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN
                {
                    Identifier identifier = new Identifier((String)id.getValue(), new int[] {id.getRow(), id.getColumn()});
                    RESULT = new CallFunction(identifier.getName(), null, new int[] {id.getRow(), id.getColumn()});
                }
                    ;

    arrayList ::= empty
                 {
                    RESULT = new ArrayList();
                 }
                 | operation:op
                 {
                    ArrayList al = new ArrayList();
                    al.AddOperation(op);
                    RESULT = al;
                 }
                 | operation:op COMMA arrayList:al
                 {
                    if(al == null) al = new ArrayList();
                    al.AddOperation(op);
                    RESULT = al;
                 }
                 ;

    empty ::=
            ;

    modifyArrayElement ::= IDENTIFIER:id OPEN_BRACKET INTEGER:i CLOSE_BRACKET EQUAL operation:op
                {
                    Identifier identifier = new Identifier((String)id.getValue(), new int[] {id.getRow(), id.getColumn()});
                    RESULT = new ModifyArray(identifier, i, op, new int[] {id.getRow(), id.getColumn()});
                }
                ;

    createArray ::= type:t IDENTIFIER:id OPEN_BRACKET INTEGER:i CLOSE_BRACKET
                {
                    Identifier identifier = new Identifier((String)id.getValue(), new int[] {id.getRow(), id.getColumn()});
                    RESULT = new CreateArray(t, identifier, i, null, new int[] {id.getRow(), id.getColumn()});
                }
                | type:t IDENTIFIER:id OPEN_BRACKET CLOSE_BRACKET EQUAL OPEN_BRACKET arrayList:al CLOSE_BRACKET
                {
                    Identifier identifier = new Identifier((String)id.getValue(), new int[] {id.getRow(), id.getColumn()});
                    RESULT = new CreateArray(t, identifier, 0, al, new int[] {id.getRow(), id.getColumn()});
                }
                ;


    create_var ::= type:t IDENTIFIER:d EQUAL operation:op
                {
                    Identifier identifier = new Identifier((String)id.getValue(), new int[] {id.getRow(), id.getColumn()});
                    RESULT = new CreateVar(t, identifier, op, new int[] {id.getRow(), id.getColumn()});
                }
                 | type:t IDENTIFIER:id
                {
                    Identifier identifier = new Identifier((String)id.getValue(), new int[] {id.getRow(), id.getColumn()});
                    RESULT = new CreateVar(t, identifier, null, new int[] {id.getRow(), id.getColumn()});
                }
                 ;

    assing_var ::= IDENTIFIER:id EQUAL operation:op
                {
                    Identifier identifier = new Identifier((String)id.getValue(), new int[] {id.getRow(), id.getColumn()});
                    RESULT = new AssignVar(identifier, op, new int[] {id.getRow(), id.getColumn()});
                }
                ;


    negation ::= empty
		| NOT
		;


    type ::= INT
            {:
                RESULT = new IntType();
            :}
           | FLOAT
           {:
                RESULT = new FloatType();
            :}
           | CHAR
            {:
                RESULT = new CharType();
            :}
           | STRING
           {:
                RESULT = new StringType();
            :}
           | BOOL
           {:
                RESULT = new BooleanType();
            :}
           ;
