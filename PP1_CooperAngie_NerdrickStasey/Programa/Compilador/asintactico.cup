package compilador;

// Importación de clases
import java_cup.runtime.*;
import java.io.FileReader;
import producciones.*;
   
/* 
  Esta sección del código se agrega a la clase resultante
*/
parser code {:
    
    /*Entrada: Es un mensaje de error de tipo String y el símbolo de tipo Object 
      Salida: No tiene
      Error encontrado.
      Se hace un Override al método report_error de la clase lr_parser de CUP 
    */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }
   
    /*Entrada: Es un mensaje de error de tipo String y el símbolo de tipo Object 
      Salida: No tiene 
      Error de donde el sistema no se puede recuper
       Se hace un Override al método report_fatal_error de la clase lr_parser de CUP
    */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
    }

    /* Se ejecuta el método main para ejecutar el analizador léxico y el analizador
       sintáctico. Se envía como parámetro la tabla de símbolos.
    */
    public static void main(String[] args){
        try {
            AnalizadorSintactico asin = new AnalizadorSintactico(
                    new AnalizadorLexico( new FileReader(args[0])));
            Object result = asin.parse().value;
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
:};
   

   
// ------------Declaracion de terminales y no terminales
   
/* TERMINALES
   Se listan todos los tokens que se vayan a utilizar para la elaboración de
   producciones, estos son obtenidos por el analizador lexico. 
*/
terminal           IDENTIFIER,
                   MINUS, PLUS, DIVIDE, MULTI, MODULE, POWER, PLUS_PLUS, MINUS_MINUS,
                   GREATER, GREATER_EQUAL, MINOR, MINOR_EQUAL, EQUAL_EQUAL, DIFFERENT, AND, OR,
                   OPEN_PAREN, CLOSE_PAREN, TRUE, FALSE, NULL, OPEN_BRACKET, CLOSE_BRACKET, COMMA,
                   INT, FLOAT, BOOL, CHAR, STRING, EQUAL, FINAL, FOR, RETURN, READ, PRINT, NOT,
                   OPEN_KEY, CLOSE_KEY, IF, ELSE, ELIF, BREAK, COMMENT,
                   MAIN;
terminal Integer   INTEGER;
terminal Double    DECIMAL;
terminal String    CHARCHAIN;
terminal Character CHARACTER;

/*NO TERMINALES 
  Se listas todos los no terminales que se elaboran en las producciones. Se utiliza Object
  para indicar que estos no tienen un tipo definido, pudiendo ser un entero o String.
*/

non terminal Object operation, relational_operator, additive_operation, additive_operator,
                    multiplicative_operation, multiplicative_operator, unary_operation,
                    unary_operator, basic_operation, empty, create_var, type, 
                    sentences, call_function, createArray, arrayList, modifyArrayElement, 
                    block, create_function, parameters, parameter_list, for_structure, if_structure, else_structure, 
                    elif_structure, main_function, assing_var, negation,
                    init_program;

   
/* -------------Precedencia y producciones
   
/*PRECEDENCIA

  En este caso se utiliza la precedencia para eliminar la ambiguedad que se genera en la producción type,
  al tener un INT que hace referencia al tipo entero y un INT[] que hace referencia al tipo arreglo, de igual manera para la ambiguedad que se presenta con 
  con el ELIF y el ELSE.
*/
  precedence right INT;
    precedence right CHAR;
  precedence right ELIF; 
  precedence right ELSE; 
  

/* PRODUCCIONES   
 
/* 
  El programa inicia con la producción init_program, esta indica que se pueden crear funciones y luego
  utilizar la función main, o solo hacer uso de esta última. A partir de esta se desencadena el uso
  de las demás producciones.
*/

    start with init_program;

    init_program ::= create_function main_function
                   | main_function
                   ;

    main_function ::= INT MAIN OPEN_PAREN CLOSE_PAREN block
                    ;

    create_function ::= create_function type IDENTIFIER OPEN_PAREN parameters CLOSE_PAREN block
                      | type IDENTIFIER OPEN_PAREN parameters CLOSE_PAREN block
                      ;

    parameters ::= empty
                 | parameters COMMA type IDENTIFIER
                 | type IDENTIFIER
                 ;

    block ::=  OPEN_KEY sentences CLOSE_KEY
            |  error CLOSE_KEY
            ; 

    sentences ::= empty
               | operation FINAL sentences
               | create_var FINAL sentences
               | assing_var FINAL sentences
               | modifyArrayElement FINAL sentences
               | createArray FINAL sentences
               | if_structure
               | FOR OPEN_PAREN for_structure CLOSE_PAREN block sentences
               | RETURN operation FINAL sentences
               | BREAK FINAL
               | PRINT OPEN_PAREN operation CLOSE_PAREN FINAL sentences
               | READ OPEN_PAREN IDENTIFIER CLOSE_PAREN FINAL sentences
               | error
               | COMMENT sentences
               ;

    for_structure ::= create_var FINAL operation FINAL operation ;

    if_structure ::= IF negation OPEN_PAREN operation CLOSE_PAREN OPEN_KEY sentences CLOSE_KEY sentences
                       	elif_structure
		        else_structure
                        ;

    else_structure ::= empty
		       |ELSE OPEN_KEY sentences CLOSE_KEY sentences
		       ;

    elif_structure ::= empty
                       | ELIF negation OPEN_PAREN operation CLOSE_PAREN OPEN_KEY sentences CLOSE_KEY sentences
		       | elif_structure ELIF negation OPEN_PAREN operation CLOSE_PAREN OPEN_KEY sentences CLOSE_KEY sentences
                       ;


    operation ::= operation:op relational_operator:ro additive_operation:ao
                  {:
                    if(ro === ">") RESULT = new Greater(op, ao, new int[] {ro.getRow(), ro.getColumn()});
                    if(ro === ">=") RESULT = new GreaterEqual(op, ao, new int[] {ro.getRow(), ro.getColumn()});
                    if(ro === "<") RESULT = new Minor(op, ao, new int[] {ro.getRow(), ro.getColumn()});
                    if(ro === "<=") RESULT = new MinorEqual(op, ao, new int[] {ro.getRow(), ro.getColumn()});
                    if(ro === "==") RESULT = new EqualEqual(op, ao, new int[] {ro.getRow(), ro.getColumn()});
                    if(ro === "!=") RESULT = new Different(op, ao, new int[] {ro.getRow(), ro.getColumn()});                    
                  :}
                | additive_operation:ao
                  {:
                    RESULT = ao;
                  :}
                ;

    relational_operator ::= GREATER:g
                            {:
                              RESULT = g;
                            :}
                          | GREATER_EQUAL:ge
                            {:
                              RESULT = ge;
                            :}
                          | MINOR:m
                            {:
                              RESULT = m;
                            :}
                          | MINOR_EQUAL:me
                            {:
                              RESULT = me;
                            :}
                          | EQUAL_EQUAL:ee
                            {:
                              RESULT = ee;
                            :}
                          | DIFFERENT:d
                            {:
                              RESULT = d;
                            :}
                          ;

    additive_operation ::= additive_operation:ao additive_operator:aop multiplicative_operation:mo
                          {:
                            if(aop === "-") RESULT = new Minus(ao, mo, new int[] {ro.getRow(), ro.getColumn()});
                            if(aop === "+") RESULT = new Plus(ao, mo, new int[] {ro.getRow(), ro.getColumn()});
                            if(aop === "|") RESULT = new Or(ao, mo, new int[] {ro.getRow(), ro.getColumn()});                
                          :}
                         | multiplicative_operation:mo
                          {:
                            RESULT = mo;
                          :}
                         ;

    additive_operator   ::= MINUS:m
                            {:
                              RESULT = m;
                            :}
                          | PLUS:p
                            {:
                              RESULT = p;
                            :}
                          | OR:o
                            {:
                              RESULT = o;
                            :}
                          ;    

    multiplicative_operation ::= multiplicative_operation:mo multiplicative_operator:mop unary_operation:uo
                                {:
                                  if(mop === "/") RESULT = new Divide(mo,uo, new int[] {ro.getRow(), ro.getColumn()});
                                  if(mop === "*") RESULT = new Multi(mo, uo, new int[] {ro.getRow(), ro.getColumn()});
                                  if(mop === "**") RESULT = new Power(mo, uo, new int[] {ro.getRow(), ro.getColumn()});
                                  if(mop === "~") RESULT = new Module(mo, uo, new int[] {ro.getRow(), ro.getColumn()});
                                  if(mop === "&") RESULT = new And(mo, uo, new int[] {ro.getRow(), ro.getColumn()});                   
                                :}
                               | unary_operation:uo
                                {:
                                  RESULT = uo;
                                :}
                               ;

    multiplicative_operator ::= DIVIDE:d
                                {:
                                  RESULT = d;
                                :}
                              | MULTI:m
                                {:
                                  RESULT = m;
                                :}
                              | POWER:p
                                {:
                                  RESULT = p;
                                :}
                              | MODULE:mo
                                {:
                                  RESULT = mo;
                                :}
                              | AND:a
                                {:
                                  RESULT = a;
                                :}
                              ; 

    unary_operation ::= unary_operator:uop unary_operation:uo
                        {:
                          if(uop === "--") RESULT = new MinusMinus(uo, new int[] {ro.getRow(), ro.getColumn()});
                          if(uop === "++") RESULT = new PlusPlus(uo, new int[] {ro.getRow(), ro.getColumn()});
                          if(uop === "-") RESULT = new MinusUnary(uo, new int[] {ro.getRow(), ro.getColumn()});                
                        :}
                      | basic_operation:ba
                        {:
                          RESULT = ba;
                        :}
                      ;

    unary_operator ::= MINUS_MINUS:mm
                      {:
                        RESULT = mm;
                      :}
                     | PLUS_PLUS:pp
                      {:
                        RESULT = pp;
                      :}
                     | MINUS:m
                      {:
                        RESULT = m;
                      :}
                     ;

    basic_operation ::= INTEGER
                      | DECIMAL
                      | CHARCHAIN
                      | CHARACTER
                      | IDENTIFIER
                      | TRUE
                      | FALSE
                      | negation OPEN_PAREN operation CLOSE_PAREN 
                      | IDENTIFIER OPEN_BRACKET INTEGER CLOSE_BRACKET
                      | OPEN_BRACKET  arrayList CLOSE_BRACKET 
                      | call_function
                      | NULL
                      ;

   parameter_list ::= parameter_list COMMA operation
                     | operation
                     ;

    call_function ::= IDENTIFIER OPEN_PAREN parameter_list CLOSE_PAREN
                    | IDENTIFIER OPEN_PAREN CLOSE_PAREN
                    ;

    arrayList ::= empty
                 | operation
                 | operation COMMA arrayList
                 ;

    empty ::=
            ;

    modifyArrayElement ::= IDENTIFIER OPEN_BRACKET INTEGER CLOSE_BRACKET EQUAL operation ;

    createArray ::= type IDENTIFIER OPEN_BRACKET INTEGER CLOSE_BRACKET
                    | type IDENTIFIER OPEN_BRACKET CLOSE_BRACKET EQUAL OPEN_BRACKET arrayList CLOSE_BRACKET
                    ;


    create_var ::= type IDENTIFIER EQUAL operation
                 | type IDENTIFIER
                 ;

    assing_var ::= IDENTIFIER EQUAL operation;


    negation ::= empty
		| NOT
		;


    type ::= INT
            {:
                RESULT = "INT";
            :}
           | FLOAT
           {:
                RESULT = "FLOAT";
            :}
           | CHAR
            {:
                RESULT = "CHAR";
            :}
           | STRING
           {:
                RESULT = "STRING";
            :}
           | BOOL
           {:
                RESULT = "BOOL";
            :}
           ;
